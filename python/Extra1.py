# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JkWNDdyOsYV0SrMC9nhZqZc_j95eEuMC
"""

#290. Word Pattern

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        dict_l = {}
        dict_w = {}
        s_list = s.split(" ")
        if len(s_list) != len(pattern):
            return False
        for index, latter in enumerate(pattern):
            word = s_list[index]
            if dict_l.get(latter) == None and dict_w.get(word) == None:
                dict_l[latter] = word
                dict_w[word] = latter
            else:
                if dict_l.get(latter) != None and dict_l.get(latter) != word:
                    return False
                if dict_w.get(word) != None and dict_w.get(word) != latter:
                    return False
        return True

pattern = "abba"
s = "dog cat cat fish"
# Answer = False
Solution().wordPattern(pattern, s)

#448. Find All Numbers Disappeared in an Array

from typing import List
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums)+1
        for i in nums:
            num = i % n
            nums[num-1] += n
        n_list = []
        for i,num in enumerate(nums):
            if num < n:
                n_list.append(i+1)
        return n_list

nums = [4,3,2,7,8,2,3,1]
# Answer = [5,6]
Solution().findDisappearedNumbers(nums)

#160. Intersection of Two Linked Lists

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
      #double points
        pointA, pointB = headA, headB
        while pointA != pointB:
            pointA = pointA.next if pointA else headB
            pointB = pointB.next if pointB else headA
        return pointA

#875. Koko Eating Bananas

from typing import List
class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        #return eating time given speed k.
        import math
        def EatingTime(piles, k):
            time = 0
            for pile in piles:
                time += math.ceil(pile / k)
            return time

        #binary search
        upper = max(piles)
        lower = math.ceil(sum(piles) / h)
        while(1):
            k = (lower+upper) // 2
            time = EatingTime(piles, k)
            if time <= h:
                if k == 1 or EatingTime(piles, k-1) > h:
                    return k
                else:
                    upper = k
            elif time > h:
                lower = k+1

piles = [3,6,7,11]
h = 8
# Answer = 4
Solution().minEatingSpeed(piles,h)

#435. Non overlapping intervals

from typing import List
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        L = sorted(intervals, key= lambda x: x[0])
        upper = -50000
        num = 0
        for interval in L:
            if interval[0] >= upper:
                upper = interval[1]
            elif  interval[1] <= upper:
                upper = interval[1]
                num += 1
            else:
                num += 1
        return num

intervals = [[1,2],[2,3],[3,4],[1,3]]
# Answer = 1
Solution().eraseOverlapIntervals(intervals)

#3. longest substring without repeating characters

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        #hash table recording the index of each character
        if len(s) < 2:
            return len(s)
        max_length = 0
        left = 0
        char_dict = {}
        for right,char in enumerate(s):
            if char_dict.get(char) == None or char_dict[char] < left:
                char_dict[char] = right
            elif char_dict[char] >= left:
                max_length = max(max_length, right-left)
                left = char_dict[char] + 1
                char_dict[char] = right

        return max(right - left + 1, max_length)

s = "abcabcbb"
# Answer = 3
Solution().lengthOfLongestSubstring(s)